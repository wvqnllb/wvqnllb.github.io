[{"categories":["Java Basic"],"content":"非常多多线程的东西","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"Java多线程基础 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:0:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"线程 进程 多线程 进程指的是占用一定内存的程序 资源分配的的单位 线程是进程中的一个执行单元 负责当前进程中的程序的执行 java的多线程 指的是 java调用系统资源创建多线程 start0(); java默认两线程 main线程 GC线程 并发编程 充分利用CPU资源 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"线程基本方法和状态 线程状态 新建 就绪 运行 阻塞 死亡 static yield() 线程礼让 暂停但是不阻塞 给一个重新竞争的机会 线程停止 建议使用一个标志位进行终止变量 在runnable里搞一个flag成员变量 线程休眠 sleep() 阻塞线程 可以指定时间 join() 线程强制执行 而且要执行完 其他线程都阻塞 守护线程daemon setDaemon(); 虚拟机必须确保用户线程执行完毕 不用太管守护线程 后才记录操作日志 监控内存 垃圾回收 wait和sleep的区别 Object#wait() 释放锁 只能在同步代码块中 Thread#sleep() 抱着锁睡觉 可以在任何地方睡 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"创建方式 //继承Thread类 重写run()方法 //匿名类 public class ThreadDemo1 extends Thread { @Override public void run() { sout(\"Thread is running\"); } } //实现Runnalbe接口 实现run方法 public class ThreadDemo2 implements Runnable { public void run(){ sout(\"xxx\"); } } //线程池+Callable ExecutorService executorService = Executors.newSingleThreadExecutor(); Future\u003cString\u003e submit = executorService.submit(()-\u003e { sout(Thread.currentThread().getName() + \"------\u003e正在执行\"); Thread.sleep(3*1000L); return \"success\"; // 可以看到call是有返回值的 泛型接口 }); String result = submit.get(); sout(\"result-------\u003e\" + result); executorService.shutdown(); ThreadDemo1 t1 = new ThreadDemo1(); t.start(); ThreadDemo2 target = new ThreadDemo2(); Thread t2 = new Thread(target); t2.start(); 区别和本质 之所以有Runnable接口 限定Thread构造方法的形参类型 将run()向上抽取 让实现类去重写 好处？ 有点解耦的味道 把原本线程类中的\"待执行代码\"挪到了Runnable实现类中 执行者和被执行者分离了 继承Thread的话 线程和待运行的代码在同一个类中 无法做到资源独立 也就无法共享 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:3:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"线程池 如何确认线程数量 cpu密集型 cpu内核数 可以保证cpu效率最高 IO密集型 15个大型任务 IO十分占用资源 应该采用大于IO数量的线程 管理线程 避免增加创建线程和销毁线程的资源损耗 线程也是对象 提高响应速度 方便管理 最终目的还是去分配不同线程执行任务 工具类Executors 线程池的工厂类 用于创建并返回不同类型的线程池 newSingleThreadExecutor 返回一个ExecutorService线程池 #execute(()-\u003e()) 用完要关闭 finally #shutdown() newFixedThreadPool newCachedThreadPool 可伸缩的 祖宗Executor接口 解耦执行器Executor#execute(Runnable runnable)和具体方法 ThreadPoolExecutor (实现ExecutorService接口) 最好直接用这个创建(Ali规范) corePoolSize 线程池中维持的线程数量 当线程池中的线程数量超过corePoolSize数量时 闲置线程将被终止 maximumPoolSize 线程池中最大允许的线程数量 队列满了之后会都打开 keepAliveTime 当线程池中的线程数量大于线程核心池（corePoolSize）允许的数量时，在终止空闲线程前允许等待新任务的时间。 Unit 这个就是keepAliveTime的单位，秒、毫秒、纳秒等 workQueue 阻塞队列该队列保存未被执行的任务。其中的任务类型是Runnable的 ThreadFactory 创建线程的工厂类 比如给线程设置名字 handler 拒绝策略类，当线程池数量达到上线并且workQueue队列长度达到上限时就需要对到来的任务做拒绝处理。默认的情况下是当以上情况发生时，抛出一个RejectedExecutionException异常 四种拒绝策略 最大承载 线程数量+队列长度 AbortPolicy 就不处理这个人 并且抛出异常 CallerRunsPolicy 哪来的去哪里 比如是main线程来的 那就让main线程来执行 DiscardPolicy 丢了 不抛出异常 DiscardOldPolicy 尝试和最早的竞争 不会抛出异常 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:4:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"Synchronized link初级 link中级 同步关键字 真正的锁是某一个对象 对象头里包含了锁信息 静态方法的锁是所在类的字节码对象 普通方法的锁是this对象！~~ synchronized是可重入的 同一个线程在已经持有该锁的情况下 可以再次获取锁 并会在某个状态量上做+1的操作 子类同步方法 调用父类的同步方法嘛 可以 用的都是this锁对象 静态同步和非静态同步方法不互斥 看八锁的例子就好了 //写一个固定容量的同步容器，拥有put和get方法，以及getCount方法，能够支持2个生产者线程以及10个消费者线程的阻塞调用 object的方法 notify notifyall 和 reetrantlock的await和singalAll()区别 1.6之后的优化： 1.6之前都是重量锁 mutex 操作系统切换内核态 阻塞和恢复浪费资源量大 1.6之后 无锁 偏向锁 单一线程执行同步代码块 提高性能 获取锁：cas获锁之后在对象头和栈帧记录中存储锁偏向的进程ID， 之后线程在进入和退出块时不需要进行cas操作来加锁解锁，只简单测试下对象头的markword中偏向锁的id字段 竞争出现：检测当前对象是不是可偏向的，再确认线程id，如果通过CAS竞争成功，换对象偏向锁字段的线程id。如果竞争失败，说明出现了竞争，到全局安全点的时候，首先暂定拥有偏向锁的线程。检查该线程是否还活着，如果已经执行完毕了，由于不会主动释放锁，将对象头设置成无锁，然后重新偏向。如果还活着，撤销偏向锁之后 升级到轻量锁的状态。 释放：采用了一种等到竞争出现才释放偏向锁的机制。 -XX:-UseBiasedLocking=false 用于关闭 轻量锁 和偏向锁一样都是乐观锁，其实是牺牲了一部分自旋的资源来交换阻塞和激活所用的资源。 重量锁 其他优化： 锁消除 如果堆上的数据不会逃逸出当前线程 可以认为是安全的 不加锁 锁粗化 连续对同一对象反复加锁解锁 可以统一加一次 -XX:PreBlcokSpin 默认的自旋次数 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"ReetrantLock手撕AQS link AQS AbstractQueuedSynchronizer JDK为线程同步提供的一套基础工具类 理解主要方法 //加锁 public void lock() { sync.lock(); } //解锁 public void unlock(){ sync.release(1); } sync ReetrantLock内部类 均继承于抽象类Sync Sync继承于AQS AQS中定义了内部类Node NonFairSync 直接抢 线程饥饿 FairSync FairSync在tryAquire方法中，当判断到锁状态字段state == 0 时，不会立马将当前线程设置为该锁的占用线程，而是去判断是在此线程之前是否有其他线程在等待这个锁（执行hasQueuedPredecessors()方法），如果是的话，则该线程会加入到等待队列中，进行排队（FIFO，先进先出的排队形式）。这也就是为什么FairSync可以让线程之间公平获得该锁。 线程排队 tryAcquire为false 获锁失败的时候 执行acquireQueued方法 队列对线程进行排队和管理 线程 队列中线程状态 前驱和后继线程 Node的数据结构 内部类 两种等待方式 SHARED 线程以共享的模式等待锁 ReadLock EXCLUSIVE 以互斥的模式等待锁 ReentrantLock 状态 CANCELLED 1 获锁请求取消 SIGNAL -1 线程早准备好的一切等待锁 CONDITION -2 线程等在某一个条件被满足 PROPAGATE -3 当处SHARED模式的时候才会被用上 成员变量 waitStatus 该int变量表示线程在队列中的状态 prev 该变量类型为Node对象，表示该节点的前一个Node节点 next 该变量类型为Node对象，表示该节点的后一个Node节点 thread 该变量类型为Thread对象，表示该节点的代表的线程 nextWaiter 该变量类型为Node对象，表示等待condition条件的Node节点 等待中的线程如何感知到锁空闲并且获得锁 下面这些都是AQS中的方法 acquiredQueued(addWaiter(Node.EXCLUSIVE),arg)中的外层方法 一个线程获取锁失败了 被放到了线程的等待队列中 把放入队列中的这个线程不断的进行获锁 直到成功获锁 或者 不再需要 一个while循环 跳出条件 p是head节点，并且当前线程获锁成功 如果就是那么不恰巧,就是不符合这个唯一跳出循环的条件”,那就一直在循环里面空跑了吗!那CPU使用率不就会飙升?! 阻塞线程 第一次循环 线程状态被设置成了signal 第二次就会被阻塞 解锁 release(1); unparkSuccessor(h)就是唤醒操作 尝试释放当前线程持有的锁 如果成功释放，那么去唤醒头结点的后继节点 头节点不保存线程信息 可重入 这里需要注意到AQS中很多内部变量的修饰符都是采用的volitale,然后配合CAS操作来保证AQS本身的线程安全(因为AQS自己线程安全,基于它的衍生类才能更好地保证线程安全),这里的state字段就是AQS类中的一个用volitale修饰的int变量 state字段初始化时,值为0。表示目前没有任何线程持有该锁。当一个线程每次获得该锁时，值就会在原来的基础上加1，多次获锁就会多次加1（指同一个线程），这里就是可重入。因为可以同一个线程多次获锁，只是对这个字段的值在原来基础上加1; 相反unlock操作也就是解锁操作，实际是是调用AQS的release操作，而每执行一次这个操作，就会对state字段在原来的基础上减1，当state==0的时候就表示当前线程已经完全释放了该锁。 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:6:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"Synchronized 和 Lock的区别 内置的java关键字 和 java类 无法判断获取锁的状态 可以获得并判断是否获取到了锁 自动释放 手动释放 如果当前方法阻塞了 其他没法获得锁 Lock锁可以tryLock 不可以中断 非公平 可以中断锁 非公平/公平 对象上重入 线程上重入 适合锁少量的代码同步 lock大量 Condition的优势 精准的通知和唤醒线程 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:7:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"FutureTask = 任务 + 结果 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:8:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"继承体系 –\u003eRunnableFuture—\u003eFuture \u0026 Runnable 能包装Runnable和Callable(构造器传入) 但本身又实现了Runnable接口 本质是Runnable 能作为任被Thread执行，但诡异的是FutureTask#get()可以获取结果 一个场景 调用时必须能够立即返回result(非阻塞) 拿到result之后 可以在随后任意时刻通过result.get()获取或是任务的最终结果(异步结果) ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:8:1","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"Callable public interface Callable\u003cV\u003e { V call() throws Exception; } //对比 interface Runnable { public abstract void run(); } Callable能接受一个泛型，然后在call方法中返回一个这个类型的值。而Runnable的run方法没有返回值 Callable的call方法可以抛出异常，而Runnable的run方法不会抛出异常。 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:8:2","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"简单例子 public class AsyncAndWaitTest { public static void main(String[] args) throws ExecutionException, InterruptedException { // FutureTask实现了Runnable，可以看做是一个任务 FutureTask\u003cString\u003e futureTask = new FutureTask\u003c\u003e(new Callable\u003cString\u003e() { @Override public String call() throws Exception { System.out.println(Thread.currentThread().getName() + \"========\u003e正在执行\"); try { Thread.sleep(3 * 1000L); } catch (InterruptedException e) { e.printStackTrace(); } return \"success\"; } }); System.out.println(Thread.currentThread().getName() + \"========\u003e启动任务\"); // 传入futureTask，启动线程执行任务 new Thread(futureTask).start(); // 获取执行结果（会阻塞3秒） String result = futureTask.get(); System.out.println(\"任务执行结束，result====\u003e\" + result); } } ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:8:3","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"如何包装Runnable Callable 里面只有一个callable的成员 如果传入runnable的话 先通过内部将Runnable包装成callable Runnable –\u003e Executors.callable() –\u003e RunnableAdapter implements Callable –\u003e FutureTask.callable 适配器模式 这里搞了个假的输出参数 反正就大概是原封不动的过一遍流程 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:8:4","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"如何被Thread执行 由于本身就是一个Runnable 所以进去的流程基本一样 然后运行target.run(); FutureTask#run()方法中 取出之前包装的任务 即成员callable 调用call方法 返回result(形式上的)或者实际的执行结果 把结果设置到某个地方 FutureTask#set() 存到一个成员变量当中 所以FutureTask = 任务 + 结果 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:8:5","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"为什么get是阻塞的 // 获取执行结果（会阻塞3秒） String result = futureTask.get(); FutureTask中定义了很多任务状态 刚创建 即将完成 完成 抛异常 任务取消 任务将被打断 任务被打断 阻塞的意义 如果获取结果的这个线程不阻塞的话 很有可能尚未执行完耗时任务 比如io 因此会获得空的result 如何做到 get里面有一个awaitdone 挺麻烦的 forloop + LockSupport ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:8:6","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"集合类的安全问题 并发修改异常 CopyOnWriteArrayList\u003c\u003e 并发修改异常 适用于多读取少添加的时候 写入时复制 优势 写入时可以读 全写入还是要加锁 全用关键字方法的话就效率更低 多个线程调用的时候 读取的是固定的 写入的时候会覆盖 在写入的时候避免覆盖造成数据问题 读写分离 CopyOnWriteArraySet\u003c\u003e ConcurrentHashMap ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:9:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"常用的辅助类 CountDownLatch 允许一个或多个线程等待 知道在其他线程中执行的一组操作完成的同步辅助 必须要执行任务的时候再使用 一个减法计数器 CyclicBarrier 构造参数 int Runnable 允许一组线程全部等待彼此到达共同屏障点的同步辅助 加法计数器 集齐七颗龙珠召唤神龙 await() Semaphore 一个计数信号量。在概念上信号量维持一组许可证 acquire() 得到 release() 释放 同一时间只能有指定数量个得到线程 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:10:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"阻塞队列 如果队列满了 就必须阻塞等待 如果队列是空的 必须阻塞等待生产 实现类 同步队列 数组阻塞队列 链表阻塞队列 四组API： 抛出异常 add remove element 不会抛出异常 offer poll peek 阻塞等待 一直阻塞 put take 超时等待 offer(“a”, 2, TimeUnit.Seconds); 超过两秒就退出 poll(2, TimeUnit.Seconds); 同步队列 SynchronousQueue 一种实现类 不存储元素 put了一个元素 就必须先取出来 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:11:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"各种锁 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:12:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"读写锁 Interface ReadWriteLock 和Lock同级 实现ReentrantReadWriteLock() 维护一堆关联的Locks 一个用于只读操作 一个用于写入 独占锁 写锁 一次只能被一个线程占有 共享锁 读锁 多个线程可以同时占有 读-读 共存 读-写 不能共存 写-写 不能共存 了解底层实现 尤其是共享锁 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:12:1","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"JMM Java内存模型 是一种概念和约定 主内存和工作内存 线程解锁前 必须把共享变量立即刷回主存 线程加锁前必须主存中最新值到工作内存中 加锁和解锁是同一把锁 8种操作 read + load use + assign store+write lock + unlock ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:13:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"Volatile解析 和可见性与有序性有关 当多线程环境同时保证了对共享资源的互斥和可见性时 就能保证线程安全 原子性 一个步骤或多个步骤 不可被拆分 流程不可被中断 可以使用原子类 可见性 一个线程对共享资源的修改 对其他线程来说是可见的 互斥访问 同一时间只允许同一个线程访问 互斥访问的代码块 称为临界区 volatile保证可见性 当线程A和线程B读取了主存上的值v，同时存一个副本在线程内部的本地内存MA和本地内存MB，当线程A对MA内的副本进行修改后，则置本地副本的变量所在的内存为M（modify）标记，同时因为本地内存MB也有该副本，这个时候本地内存MB的该变量的所在内存被标记为I（Invalid）标记，当线程B对本地内存MB内的共享数据进行读取时，发现标记无效，则使本地内存MA上modify的数据写回主存，然后线程B再从内存中读取该值进行操作（也可能是直接到MA中读取）。为什么保证可见性仍然不能保证形成安全就在于，当线程A和线程B同时对本地内存进行操作时，因为这个时候两个线程内的数据都是原来的数据，双方已经一致，因此也可以同时进行操作，操作后同时提交到总线上进行cache之间的同步，这个时候就该协议就会失效。 volatile保证有序性 禁止重排序 应用 状态量标记 单例模式的实现 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:14:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"单例模式 饿汉式单例 浪费内存 static对象 懒汉式单例 就是在getInstance里面构建 单线程下单例ok 并发下 双重检测锁模式 DCL懒汉式 public static LazyMan getInstance() { if (lazyMan == null) { synchronized (LazyMan.class) { if (lazyMan == null) { lazyMan = new LazyMan(); /** 不是原子性操作 * 1 分配内存空间 * 2 执行构造方法 * 3 把这个对象指向这个空间 * 如果线程A 132 * 线程B会判断不等于null 然后就获得不到单例对象 */ } } } return lazyMan; } //所以一定要加volatile 还是可以用反射破坏单例 构造器上再加锁 信号灯 枚举 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:15:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"深入理解CAS CAS: 比较并交换 本省只有成功和失败两种状态 getAndIncrement:不会陷入无限循环 因为会一直从内存中读出当前的值 link 内存位置的内容和给定值进行比较 只有在相同的情况下 将给内存位置的内容修改为新给定的值,这是作为单个原子操作完成的. Java无法操作内存 unsafe 可以调用C++ native 可以通过这个类操作内存 比较当前工作内存的值和主内存中的值 如果这个值是期望的 那么则执行操作 如果不是一直循环 循环会耗时 一次性只能保证一个共享变量的原子性 ABA问题 自旋锁 public final int getAndAddInt(Object var1, long var2, int var4) { int var5; do { var5 = this.getIntVolatile(var1, var2); } while (!this.compareAndSwapInt(var1, var2, var5, var5+var4)) } ABA问题 另一个线程换过但是不知道 原子引用 AutomicStampedReference 初始化参数 初始值 + 时间戳 解决ABA问题 注意使用Integer时 如果超过-128 - 127的情况下 会重新构建对象 Integer是在Integer Cache.cache产生 会复用 这个区间外的所有数据 都不会复用 乐观锁 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:16:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Java Basic"],"content":"各种锁的理解 公平锁 非公平锁 先来后到 和 竞争 默认都是非公平 Lock 可重入锁 递归锁 synchronized 和 ReentrantLock的区别 锁一次 锁两次 锁必须配对 不然就会死在里面 自旋锁 SpinLock getAndIncrement int var5; do { var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); AutomicReference\u003cThread\u003e automicReference = new AutomicReference(); public void myLock() { Thread thread = Thread.currentThread(); System.out.println(Thread.currentThread.getName()+\"myLock\"); //自旋锁 while (automicReference.compareAndSet(null, thread)) { } } public void myUnLock() { Thread = Thread.currentThread(); System.out.printlin(Thread.currentThread.getName()+\"UnLock\"); atomicReference.compareAndSet(thread, null); } 死锁 是什么？ 怎么排除死锁 使用jps-l定位进程号 jstack进程号 找到死锁 四要素 互斥条件 一个资源每次只能被一个进程使用 请求和保持条件 一个进程因请求资源而阻塞时 对已获得的资源保持不放 不剥夺条件 进程已经获得的资源 未使用完之前 不能强行剥夺 循环等待条件 若干进程之间形成一种头尾相接的循环等待资源关系 ","date":"2020-10-16","objectID":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/:17:0","tags":["Java Basic"],"title":"Java多线程","uri":"/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["Leetcode"],"content":"并查集总结和相关题目","date":"2020-08-04","objectID":"/leetcode-unionfind/","tags":["UnionFind"],"title":"Leetcode UnionFind","uri":"/leetcode-unionfind/"},{"categories":["Leetcode"],"content":"UnionFind ","date":"2020-08-04","objectID":"/leetcode-unionfind/:1:0","tags":["UnionFind"],"title":"Leetcode UnionFind","uri":"/leetcode-unionfind/"},{"categories":["Leetcode"],"content":"数组实现 实现还是非常简单的~ 实现细节： 用负数标注当前树的大小 将小树附加到大树上，避免出现低效率情况 进行根节点查找时进行路径压缩 public class UnionFind { public int[] parents; public UnionFind (int size) { parents = new int[size]; //初始全部为大小为1的单独子树 Arrays.fill(parents, -1); } //path compreesion public int findRoot(int v) { if (parents[v] \u003c 0) { return v; } parents[v] = findRoot(parents[v]); return parents[v]; } public void union (int v1, int v2) { int r1 = findRoot(v1); int r2 = findRoot(v2); if (r1 == r2) { return; } //小树的根作为大树根的儿子，更新大树根 if (-parents[r1] \u003e -parents[r2]) { parents[r1] += parents[r2]; parents[r2] = r1; } else { parents[r2] += parents[r1]; parents[r1] = r2; } } //判断是否在同一树中 public boolean find(int v1, int v2) { int r1 = findRoot(v1); int r2 = findRoot(v2); if (r1 == r2) { return true; } return false; } } ","date":"2020-08-04","objectID":"/leetcode-unionfind/:1:1","tags":["UnionFind"],"title":"Leetcode UnionFind","uri":"/leetcode-unionfind/"},{"categories":["Leetcode"],"content":"leetcode200 岛屿数量 题目链接 dfs: 采用dfs并判断dfs次数 class Solution { void dfs(char[][] grid, int r, int c) { int nr = grid.length; int nc = grid[0].length; if (r \u003c 0 || c \u003c 0 || r \u003e= nr || c \u003e= nc || grid[r][c] == '0') { return; } grid[r][c] = '0'; dfs(grid, r - 1, c); dfs(grid, r + 1, c); dfs(grid, r, c - 1); dfs(grid, r, c + 1); } public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) { return 0; } int nr = grid.length; int nc = grid[0].length; int num_islands = 0; for (int r = 0; r \u003c nr; ++r) { for (int c = 0; c \u003c nc; ++c) { if (grid[r][c] == '1') { ++num_islands; dfs(grid, r, c); } } } return num_islands; } } //来源：LeetCode bfs: 队列迭代实现 class Solution { void dfs(char[][] grid, int r, int c) { int nr = grid.length; int nc = grid[0].length; if (r \u003c 0 || c \u003c 0 || r \u003e= nr || c \u003e= nc || grid[r][c] == '0') { return; } grid[r][c] = '0'; dfs(grid, r - 1, c); dfs(grid, r + 1, c); dfs(grid, r, c - 1); dfs(grid, r, c + 1); } public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) { return 0; } int nr = grid.length; int nc = grid[0].length; int num_islands = 0; for (int r = 0; r \u003c nr; ++r) { for (int c = 0; c \u003c nc; ++c) { if (grid[r][c] == '1') { ++num_islands; dfs(grid, r, c); } } } return num_islands; } } //来源：LeetCode UnionFind实现 //时间复杂度O(mn) * α(x) //空间复杂度O(mn) class Solution { int m; int n; public class UnionFind { public int[] parents; public UnionFind (char[][] grid) { this.parents = new int[m * n]; Arrays.fill(parents, -1); } //path compreesion public int findRoot(int v) { if (parents[v] \u003c 0) { return v; } parents[v] = findRoot(parents[v]); return parents[v]; } public void union (int v1, int v2) { int r1 = findRoot(v1); int r2 = findRoot(v2); if (r1 == r2) { return; } if (-parents[r1] \u003e -parents[r2]) { parents[r1] += parents[r2]; parents[r2] = r1; } else { parents[r2] += parents[r1]; parents[r1] = r2; } } public boolean find(int v1, int v2) { int r1 = findRoot(v1); int r2 = findRoot(v2); if (r1 == r2) { return true; } return false; } } public int numIslands(char[][] grid) { int count0 = 0; int res = 0; if (grid == null || grid.length == 0) { return res; } m = grid.length; n = grid[0].length; UnionFind uf = new UnionFind(grid); for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1') { int index1 = getIndex(i, j); if (i \u003e 0 \u0026\u0026 grid[i - 1][j] == '1') { int index2 = getIndex(i - 1, j); uf.union(index1, index2); } if (j \u003e 0 \u0026\u0026 grid[i][j - 1] == '1') { int index2 = getIndex(i, j - 1); uf.union(index1, index2); } } else { count0++; } } } for (int i : uf.parents) { if (i \u003c 0) { res++; } } return res - count0; } public int getIndex(int r, int c) { return r * n + c; } } ","date":"2020-08-04","objectID":"/leetcode-unionfind/:1:2","tags":["UnionFind"],"title":"Leetcode UnionFind","uri":"/leetcode-unionfind/"},{"categories":["Leetcode"],"content":"二分总结和相关题目","date":"2020-08-03","objectID":"/leetcode-binarysearch/","tags":["BinarySearch"],"title":"Leetcode BinarySearch","uri":"/leetcode-binarysearch/"},{"categories":["Leetcode"],"content":"二分总结和相关题目。 ","date":"2020-08-03","objectID":"/leetcode-binarysearch/:0:0","tags":["BinarySearch"],"title":"Leetcode BinarySearch","uri":"/leetcode-binarysearch/"},{"categories":["Leetcode"],"content":"binarySearch的两种情况 在范围当中一定可以找到 结束条件明确，直接break； 结束条件不明确，收敛到 lo == hi, 即为最终位置 在范围当中不一定可以找到 将找到和找不到两种情况以不同方式输出(Java Arrays的实现); 找到收敛位置之后判断该位置元素是否满足条件 lo \u003e hi； 类型1在leetcode题目中更加多见，难点经常在于如何将题目转换为二分的结束条件。 类型2感觉是在底层实现中更多一些，通用性更强。 ","date":"2020-08-03","objectID":"/leetcode-binarysearch/:1:0","tags":["BinarySearch"],"title":"Leetcode BinarySearch","uri":"/leetcode-binarysearch/"},{"categories":["Leetcode"],"content":"java.Arrays.binarySearch(); 类似 2.1 private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key) { int low = fromIndex; int high = toIndex - 1; while (low \u003c= high) { int mid = (low + high) \u003e\u003e\u003e 1; int midVal = a[mid]; if (midVal \u003c key) low = mid + 1; else if (midVal \u003e key) high = mid - 1; else return mid; // key found } return -(low + 1); // key not found. } ","date":"2020-08-03","objectID":"/leetcode-binarysearch/:2:0","tags":["BinarySearch"],"title":"Leetcode BinarySearch","uri":"/leetcode-binarysearch/"},{"categories":["Leetcode"],"content":"自己实现的通用方法 类似 2.2 public static int binarytsearch(int[] vec, int targetNumber, int lo, int hi) { while(lo \u003c= hi) { int mi = (lo + hi) / 2; if (targetNumber \u003c vec[mi]) { hi = mi - 1; } else { lo = mi + 1; } } return --lo; } ","date":"2020-08-03","objectID":"/leetcode-binarysearch/:3:0","tags":["BinarySearch"],"title":"Leetcode BinarySearch","uri":"/leetcode-binarysearch/"},{"categories":["Leetcode"],"content":"Leecode410 分割数组的最大值 题目链接 二分题解：最大最小问题 贪心地模拟分割的过程，从前到后遍历数组，用 sum 表示当前分割子数组的和，cnt 表示已经分割出的子数组的数量（包括当前子数组），那么每当 sum 加上当前值超过了 x，我们就把当前取的值作为新的一段分割子数组的开头，并将 cnt 加 11。遍历结束后验证是否 cnt 不超过 m。 接下来确定ans范围，因为m在范围[1,n]内，因此ans_right为数组和，ans_left为数组中最大的元素值，并且在该范围内一定可以找到最终ans。 class Solution { public int splitArray(int[] nums, int m) { int left = 0, right = 0; for (int i = 0; i \u003c nums.length; i++) { right += nums[i]; if (left \u003c nums[i]) { left = nums[i]; } } while (left \u003c right) { int mid = (right - left) / 2 + left; if (check(nums, mid, m)) { right = mid; } else { left = mid + 1; } } return left; } public boolean check(int[] nums, int x, int m) { int sum = 0; int cnt = 1; for (int i = 0; i \u003c nums.length; i++) { if (sum + nums[i] \u003e x) { cnt++; sum = nums[i]; } else { sum += nums[i]; } } return cnt \u003c= m; } } 作者：LeetCode-Solution ","date":"2020-08-03","objectID":"/leetcode-binarysearch/:4:0","tags":["BinarySearch"],"title":"Leetcode BinarySearch","uri":"/leetcode-binarysearch/"},{"categories":["Java"],"content":"学习了基本的Java反射特性","date":"2020-07-27","objectID":"/javareflection/","tags":["Java"],"title":"Java Reflection","uri":"/javareflection/"},{"categories":["Java"],"content":"学习了基本了Java反射特性。 ","date":"2020-07-27","objectID":"/javareflection/:0:0","tags":["Java"],"title":"Java Reflection","uri":"/javareflection/"},{"categories":["Java"],"content":"Intro The reflection library gives you a very rich and elaborate toolset to write programs that manipulate Java code dynamically. It is of interest mainly to tool builders. A program that can analyze the capabilities of classes is called reflective. Usage: Ananlyze the capabilities of classes at runtime Inspect objects at runtime Implement generic array manipulation code Take advantage of Method object that work just like funcion pointers in languages such as C++ ","date":"2020-07-27","objectID":"/javareflection/:1:0","tags":["Java"],"title":"Java Reflection","uri":"/javareflection/"},{"categories":["Java"],"content":"The Class Class By working with the special Java class, you can access run time type identification information on all objects. The following code shows different way of get a Class Object Employee e; . . . Class c1 = e.getClass(); Class c2 = T.class; //T is any Java type; //e.g. java.util.Random Class c3 = Class.forName(className); //className //e.g. \"java.util.Random\" //Any method that calls this method needs a throws declearation. Comprehensive example Employee e = new Employee(); Class c1 = e.getClass(); String Name = c1.getName(); Class c2 = Employee.class(); Class c3 = Class.getClass(Name); // c1 == c2 == c3 Constructor constructor = c1.getConstructor(); Object obj = constructor.newInstance(Object...Params); ","date":"2020-07-27","objectID":"/javareflection/:2:0","tags":["Java"],"title":"Java Reflection","uri":"/javareflection/"},{"categories":["Java"],"content":"Using Reflection to Analyze the Capabilities of Classes Reflection mechanism allows you to examine the structure of a class Field Method Constructor Using the following program, we can analyze any class that the Java interpreter can load. package reflection; import java.util.*; import java.lang.reflect.*; public class ReflectionTest { public static void main(String[] args) throws ReflectiveOperationException{ String name; if (args.length \u003e 0) { name = args[0]; } else { var in = new Scanner(System.in); System.out.println(\"Enter class name (e.g. java.util.Date)\"); name = in.next(); } Class c1 = Class.forName(name); Class superc1 = c1.getSuperclass(); String modifiers = Modifier.toString(c1.getModifiers()); // 打印出类前的modifier if (modifiers.length() \u003e 0) { System.out.print(modifiers + \" \"); } // 打印类名 和 父类名 System.out.print(\"class \" + name + \" \"); if (superc1 != null \u0026\u0026 superc1 != Object.class) { System.out.print(\"extends \" + superc1.getName()); } System.out.print(\"\\n{\\n\"); printConstructors(c1); System.out.println(); printMethods(c1); System.out.println(); printFields(c1); System.out.println(\"}\"); } // 打印Constructor的 Modifier + name + parameterTpyes public static void printConstructors(Class c1) { Constructor[] constructors = c1.getDeclaredConstructors(); for (Constructor c : constructors) { String name = c.getName(); System.out.print(\" \"); String modifiers = Modifier.toString(c.getModifiers()); if (modifiers.length() \u003e 0) { System.out.print(modifiers + \" \"); } System.out.print(name + \"(\"); Class[] paramTypes = c.getParameterTypes(); for (int i = 0; i \u003c paramTypes.length; i++) { if (i \u003e 0) { System.out.print(\",\"); } System.out.print(paramTypes[i].getName()); } System.out.println(\");\"); } } // 打印Method的 modifier + returnTypes + name + parameterTypes private static void printMethods(Class c1) { Method[] methods = c1.getMethods(); for (Method m : methods) { Class retType = m.getReturnType(); String name = m.getName(); System.out.print(\" \"); String modifiers = Modifier.toString(m.getModifiers()); if (modifiers.length() \u003e 0) { System.out.print(modifiers + \" \"); } System.out.print(retType.getName() + \" \" + name + \"(\"); Class[] paramTypes = m.getParameterTypes(); for (int j = 0; j \u003c paramTypes.length; j++) { if (j \u003e 0) { System.out.print(\", \"); } System.out.print(paramTypes[j].getName()); } System.out.println(\");\"); } } // 打印Fields 的 Modifier parameterTypes Name private static void printFields(Class c1) { Field[] filelds = c1.getFields(); for (Field f : filelds) { Class type = f.getType(); String name = f.getName(); System.out.print(\" \"); String modifiers = Modifier.toString(f.getModifiers()); if (modifiers.length() \u003e 0) { System.out.print(modifiers + \" \"); } System.out.println(type.getName() + \" \" + name + \";\"); } } } ","date":"2020-07-27","objectID":"/javareflection/:3:0","tags":["Java"],"title":"Java Reflection","uri":"/javareflection/"},{"categories":["Java"],"content":"Using Reflection to Analyze Object at Runtime Of course, it is easy to look at the contents of a specific field of an object whose name and type are known when writing a program. But reflection lets you look at fields of objects that were not known at compile time. var harry = new Employee (\"Harry Hacker\", 50000, 10, 1, 1989); var jennie = new Employee(\"Jennie Kim\", 5000, 16, 1, 1996); Class c1 = harry.getClass(); Field f = c1.getDeclaredField(\"name\"); Object v= f.get(harry); f.set(harry, \"Harry Potter\"); //Only possible when \"name\" field is not private; f.setAccessible(true); //Now ok if call f.get(harry); Here is an example of a universal toString Method (是一个非常好的加深理解的例子) ObjectAnalyzerTest.java package objectAnalyzer; import java.util.*; /** * This program uses reflection to spy on object. */ public class ObjectAnalyzerTest { public static void main(String[] args) throws ReflectiveOperationException{ var squares = new ArrayList\u003cInteger\u003e(); System.out.println(Integer.class.isPrimitive()); for (int i = 1; i \u003c= 5; i++) { squares.add(i * i); } System.out.println(new ObjectAnalyzer().toString(squares)); } } ObjectAnalyzer.java package objectAnalyzer; import java.lang.reflect.AccessibleObject; import java.lang.reflect.Array; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.ArrayList; public class ObjectAnalyzer { private ArrayList\u003cObject\u003e visited = new ArrayList\u003c\u003e(); public String toString(Object obj) throws ReflectiveOperationException{ if (obj == null) return \"null\"; if (visited.contains(obj)) { return \"...\"; } visited.add(obj); Class c1 = obj.getClass(); if (c1 == String.class) { return (String) obj; } if (c1.isArray()) { String r = c1.getComponentType() + \"[]{\"; for (int i = 0; i \u003c Array.getLength(obj); i++) { if (i \u003e 0) { r += \",\"; } Object val = Array.get(obj, i); if (c1.getComponentType().isPrimitive()) r += val; else r += toString(val); } return r + \"}\"; } String r = c1.getName(); do { r += \"[\"; Field[] fields = c1.getDeclaredFields(); AccessibleObject.setAccessible(fields, true); for (Field f : fields) { if (!Modifier.isStatic(f.getModifiers())) { if (!r.endsWith(\"[\")) r+= \",\"; r += f.getName() + \"=\"; Class t = f.getType(); Object val = f.get(obj); if (t.isPrimitive()) r += val; else r+= toString(val); } } r += \"]\"; c1 = c1.getSuperclass(); } while (c1 != null); return r; } } ","date":"2020-07-27","objectID":"/javareflection/:4:0","tags":["Java"],"title":"Java Reflection","uri":"/javareflection/"},{"categories":["Java"],"content":"Using Reflection to Write Generic Array Code Allow you to create arrays dynamically. Problem: How can we write such a generic method? var a = new Employee[100]; a = Arrays.copyOf(a, 2 * a.length); One way is to create a new Object[] array in the method and return it. However, an array of objects cannot be cast to an array of employees. The virtual machine would generate a ClassCastException at runtime. The point is that, as we mentioned earlier, a Java array remembers the type of its entries – that is the element type used in the new expression that created it. It is legal to cast an Employee[] temporarily to an Object[] array and then cast it back. But an array that started its lef as an Object[] array can never be cast into an Employee[] array. Here is a good way to implement copy using reflection. public static Object goodCopyOf(Object a, int newLength) { Class c1 = a.getClass(); if (!c1.isArray()) return null; Class componentType = c1.getComponentType(); int length = Array.getLength(a); Object newArray = Array.newInstance(componentType, newLength); System.arraycopy(a,0,newArray,0,Math.min(length, newLength)); } ","date":"2020-07-27","objectID":"/javareflection/:5:0","tags":["Java"],"title":"Java Reflection","uri":"/javareflection/"},{"categories":["Java"],"content":"Invoking Arbitrary Methods and Constructors Recall that we can inspect a field of an object with getMethod of the Field class. Similarly, the Method class has an invoke method that lets you call the method that is wrapped in the current Method object. Object invoke(Object obj, Object... args) If the return type is a primitive type, the invoke method will return the wrapper type instead. Two ways to get the target Method object Class c = a.getClass(); Method[] methods = c.getDeclaredMethods(); // Then choose the specific method; // or Method method = c.getMethod(String name, Class... parameterTypes); ","date":"2020-07-27","objectID":"/javareflection/:6:0","tags":["Java"],"title":"Java Reflection","uri":"/javareflection/"},{"categories":["Blog"],"content":"个人搭建和修改博客的过程","date":"2020-07-16","objectID":"/nn%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","tags":["Blog"],"title":"NN的博客搭建","uri":"/nn%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Blog"],"content":"你好你好！ 1 博客框架采用了LoveIt 2 评论系统采用了Valine 3 添加了不同设备上的icon支持 4 修改了dark light mode的配色 …. ","date":"2020-07-16","objectID":"/nn%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:0:0","tags":["Blog"],"title":"NN的博客搭建","uri":"/nn%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"Markdown syntax \u0026 shortcuts 注意\r\r这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. \r\r 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧\r\r 将此页保存为书签，以备将来参考!\r\r ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:0:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID\r\r要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e \r\r ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:1:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:2:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:3:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:4:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:5:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:6:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:6:1","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:6:2","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:6:3","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:6:4","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:7:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:8:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:8:1","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧\r\r如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem \r\r ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:8:2","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:8:3","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:9:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:9:1","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments\rline 1 of code\rline 2 of code\rline 3 of code\r 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:9:2","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:9:3","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意\r\rHugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode.\r\r ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:9:4","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐\r\r在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. \r\r ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:10:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:11:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:11:1","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:11:2","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意\r\r定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了.\r\r ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:11:3","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:12:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \"\rThe Stormtroopocat\r 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \"\rThe Dojocat\r 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧\r\rLoveIt 主题提供了一个包含更多功能的 图片的 shortcode.\r\r 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:13:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"}]