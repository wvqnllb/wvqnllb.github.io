[{"categories":["Leetcode"],"content":"并查集总结和相关题目","date":"2020-08-04","objectID":"/leetcode-unionfind/","tags":["UnionFind"],"title":"Leetcode UnionFind","uri":"/leetcode-unionfind/"},{"categories":["Leetcode"],"content":"UnionFind ","date":"2020-08-04","objectID":"/leetcode-unionfind/:1:0","tags":["UnionFind"],"title":"Leetcode UnionFind","uri":"/leetcode-unionfind/"},{"categories":["Leetcode"],"content":"数组实现 实现还是非常简单的~ 实现细节： 用负数标注当前树的大小 将小树附加到大树上，避免出现低效率情况 进行根节点查找时进行路径压缩 public class UnionFind { public int[] parents; public UnionFind (int size) { parents = new int[size]; //初始全部为大小为1的单独子树 Arrays.fill(parents, -1); } //path compreesion public int findRoot(int v) { if (parents[v] \u003c 0) { return v; } parents[v] = findRoot(parents[v]); return parents[v]; } public void union (int v1, int v2) { int r1 = findRoot(v1); int r2 = findRoot(v2); if (r1 == r2) { return; } //小树的根作为大树根的儿子，更新大树根 if (-parents[r1] \u003e -parents[r2]) { parents[r1] += parents[r2]; parents[r2] = r1; } else { parents[r2] += parents[r1]; parents[r1] = r2; } } //判断是否在同一树中 public boolean find(int v1, int v2) { int r1 = findRoot(v1); int r2 = findRoot(v2); if (r1 == r2) { return true; } return false; } } ","date":"2020-08-04","objectID":"/leetcode-unionfind/:1:1","tags":["UnionFind"],"title":"Leetcode UnionFind","uri":"/leetcode-unionfind/"},{"categories":["Leetcode"],"content":"leetcode200 岛屿数量 题目链接 dfs: 采用dfs并判断dfs次数 class Solution { void dfs(char[][] grid, int r, int c) { int nr = grid.length; int nc = grid[0].length; if (r \u003c 0 || c \u003c 0 || r \u003e= nr || c \u003e= nc || grid[r][c] == '0') { return; } grid[r][c] = '0'; dfs(grid, r - 1, c); dfs(grid, r + 1, c); dfs(grid, r, c - 1); dfs(grid, r, c + 1); } public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) { return 0; } int nr = grid.length; int nc = grid[0].length; int num_islands = 0; for (int r = 0; r \u003c nr; ++r) { for (int c = 0; c \u003c nc; ++c) { if (grid[r][c] == '1') { ++num_islands; dfs(grid, r, c); } } } return num_islands; } } //来源：LeetCode bfs: 队列迭代实现 class Solution { void dfs(char[][] grid, int r, int c) { int nr = grid.length; int nc = grid[0].length; if (r \u003c 0 || c \u003c 0 || r \u003e= nr || c \u003e= nc || grid[r][c] == '0') { return; } grid[r][c] = '0'; dfs(grid, r - 1, c); dfs(grid, r + 1, c); dfs(grid, r, c - 1); dfs(grid, r, c + 1); } public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) { return 0; } int nr = grid.length; int nc = grid[0].length; int num_islands = 0; for (int r = 0; r \u003c nr; ++r) { for (int c = 0; c \u003c nc; ++c) { if (grid[r][c] == '1') { ++num_islands; dfs(grid, r, c); } } } return num_islands; } } //来源：LeetCode UnionFind实现 //时间复杂度O(mn) * α(x) //空间复杂度O(mn) class Solution { int m; int n; public class UnionFind { public int[] parents; public UnionFind (char[][] grid) { this.parents = new int[m * n]; Arrays.fill(parents, -1); } //path compreesion public int findRoot(int v) { if (parents[v] \u003c 0) { return v; } parents[v] = findRoot(parents[v]); return parents[v]; } public void union (int v1, int v2) { int r1 = findRoot(v1); int r2 = findRoot(v2); if (r1 == r2) { return; } if (-parents[r1] \u003e -parents[r2]) { parents[r1] += parents[r2]; parents[r2] = r1; } else { parents[r2] += parents[r1]; parents[r1] = r2; } } public boolean find(int v1, int v2) { int r1 = findRoot(v1); int r2 = findRoot(v2); if (r1 == r2) { return true; } return false; } } public int numIslands(char[][] grid) { int count0 = 0; int res = 0; if (grid == null || grid.length == 0) { return res; } m = grid.length; n = grid[0].length; UnionFind uf = new UnionFind(grid); for (int i = 0; i \u003c m; i++) { for (int j = 0; j \u003c n; j++) { if (grid[i][j] == '1') { int index1 = getIndex(i, j); if (i \u003e 0 \u0026\u0026 grid[i - 1][j] == '1') { int index2 = getIndex(i - 1, j); uf.union(index1, index2); } if (j \u003e 0 \u0026\u0026 grid[i][j - 1] == '1') { int index2 = getIndex(i, j - 1); uf.union(index1, index2); } } else { count0++; } } } for (int i : uf.parents) { if (i \u003c 0) { res++; } } return res - count0; } public int getIndex(int r, int c) { return r * n + c; } } ","date":"2020-08-04","objectID":"/leetcode-unionfind/:1:2","tags":["UnionFind"],"title":"Leetcode UnionFind","uri":"/leetcode-unionfind/"},{"categories":["leetcode"],"content":"总结了图的最短路径和最小生成树","date":"2020-08-03","objectID":"/ms_sp/","tags":["AdjacentList","Dfs","PriorityQueue"],"title":"ShortestPathTree \u0026 MinimumSpanningTree","uri":"/ms_sp/"},{"categories":["leetcode"],"content":"Dijkstra/A*/Prim/Kruskal Algorithms ","date":"2020-08-03","objectID":"/ms_sp/:0:0","tags":["AdjacentList","Dfs","PriorityQueue"],"title":"ShortestPathTree \u0026 MinimumSpanningTree","uri":"/ms_sp/"},{"categories":["leetcode"],"content":"ShortestPathTree SlideLink ","date":"2020-08-03","objectID":"/ms_sp/:1:0","tags":["AdjacentList","Dfs","PriorityQueue"],"title":"ShortestPathTree \u0026 MinimumSpanningTree","uri":"/ms_sp/"},{"categories":["leetcode"],"content":"problem: Single Source Single Target Shortest Path 在图中规定一个起始节点，那么从该起始节点到其余每个结点的最短路径形成的就是最短路径树。在边的权值不为负数的情况下不可能出现闭环的情况。 ","date":"2020-08-03","objectID":"/ms_sp/:1:1","tags":["AdjacentList","Dfs","PriorityQueue"],"title":"ShortestPathTree \u0026 MinimumSpanningTree","uri":"/ms_sp/"},{"categories":["leetcode"],"content":"Dijkstra算法 DemoLink 概述 采用该算法解决最短路径问题的流程： 根据描述建立图的邻接表 初始化一个优先级队列，储存的是图中的所有结点，每个节点对应的优先度又它当前距离起点的距离决定。优先度在结点未被发现的情况下只有root为0，其余皆为正无穷。 简单证明 Pseudocode ","date":"2020-08-03","objectID":"/ms_sp/:1:2","tags":["AdjacentList","Dfs","PriorityQueue"],"title":"ShortestPathTree \u0026 MinimumSpanningTree","uri":"/ms_sp/"},{"categories":["leetcode"],"content":"Minimum Spanning Tree","date":"2020-08-03","objectID":"/ms_sp/:2:0","tags":["AdjacentList","Dfs","PriorityQueue"],"title":"ShortestPathTree \u0026 MinimumSpanningTree","uri":"/ms_sp/"},{"categories":["Leetcode"],"content":"二分总结和相关题目","date":"2020-08-03","objectID":"/leetcode-binarysearch/","tags":["BinarySearch"],"title":"Leetcode BinarySearch","uri":"/leetcode-binarysearch/"},{"categories":["Leetcode"],"content":"二分总结和相关题目。 ","date":"2020-08-03","objectID":"/leetcode-binarysearch/:0:0","tags":["BinarySearch"],"title":"Leetcode BinarySearch","uri":"/leetcode-binarysearch/"},{"categories":["Leetcode"],"content":"binarySearch的两种情况 在范围当中一定可以找到 结束条件明确，直接break； 结束条件不明确，收敛到 lo == hi, 即为最终位置 在范围当中不一定可以找到 将找到和找不到两种情况以不同方式输出(Java Arrays的实现); 找到收敛位置之后判断该位置元素是否满足条件 lo \u003e hi； 类型1在leetcode题目中更加多见，难点经常在于如何将题目转换为二分的结束条件。 类型2感觉是在底层实现中更多一些，通用性更强。 ","date":"2020-08-03","objectID":"/leetcode-binarysearch/:1:0","tags":["BinarySearch"],"title":"Leetcode BinarySearch","uri":"/leetcode-binarysearch/"},{"categories":["Leetcode"],"content":"java.Arrays.binarySearch(); 类似 2.1 private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key) { int low = fromIndex; int high = toIndex - 1; while (low \u003c= high) { int mid = (low + high) \u003e\u003e\u003e 1; int midVal = a[mid]; if (midVal \u003c key) low = mid + 1; else if (midVal \u003e key) high = mid - 1; else return mid; // key found } return -(low + 1); // key not found. } ","date":"2020-08-03","objectID":"/leetcode-binarysearch/:2:0","tags":["BinarySearch"],"title":"Leetcode BinarySearch","uri":"/leetcode-binarysearch/"},{"categories":["Leetcode"],"content":"自己实现的通用方法 类似 2.2 public static int binarytsearch(int[] vec, int targetNumber, int lo, int hi) { while(lo \u003c= hi) { int mi = (lo + hi) / 2; if (targetNumber \u003c vec[mi]) { hi = mi - 1; } else { lo = mi + 1; } } return --lo; } ","date":"2020-08-03","objectID":"/leetcode-binarysearch/:3:0","tags":["BinarySearch"],"title":"Leetcode BinarySearch","uri":"/leetcode-binarysearch/"},{"categories":["Leetcode"],"content":"Leecode410 分割数组的最大值 题目链接 二分题解：最大最小问题 贪心地模拟分割的过程，从前到后遍历数组，用 sum 表示当前分割子数组的和，cnt 表示已经分割出的子数组的数量（包括当前子数组），那么每当 sum 加上当前值超过了 x，我们就把当前取的值作为新的一段分割子数组的开头，并将 cnt 加 11。遍历结束后验证是否 cnt 不超过 m。 接下来确定ans范围，因为m在范围[1,n]内，因此ans_right为数组和，ans_left为数组中最大的元素值，并且在该范围内一定可以找到最终ans。 class Solution { public int splitArray(int[] nums, int m) { int left = 0, right = 0; for (int i = 0; i \u003c nums.length; i++) { right += nums[i]; if (left \u003c nums[i]) { left = nums[i]; } } while (left \u003c right) { int mid = (right - left) / 2 + left; if (check(nums, mid, m)) { right = mid; } else { left = mid + 1; } } return left; } public boolean check(int[] nums, int x, int m) { int sum = 0; int cnt = 1; for (int i = 0; i \u003c nums.length; i++) { if (sum + nums[i] \u003e x) { cnt++; sum = nums[i]; } else { sum += nums[i]; } } return cnt \u003c= m; } } 作者：LeetCode-Solution ","date":"2020-08-03","objectID":"/leetcode-binarysearch/:4:0","tags":["BinarySearch"],"title":"Leetcode BinarySearch","uri":"/leetcode-binarysearch/"},{"categories":["Java"],"content":"学习了基本的Java反射特性","date":"2020-07-27","objectID":"/javareflection/","tags":["Java"],"title":"Java Reflection","uri":"/javareflection/"},{"categories":["Java"],"content":"学习了基本了Java反射特性。 ","date":"2020-07-27","objectID":"/javareflection/:0:0","tags":["Java"],"title":"Java Reflection","uri":"/javareflection/"},{"categories":["Java"],"content":"Intro The reflection library gives you a very rich and elaborate toolset to write programs that manipulate Java code dynamically. It is of interest mainly to tool builders. A program that can analyze the capabilities of classes is called reflective. Usage: Ananlyze the capabilities of classes at runtime Inspect objects at runtime Implement generic array manipulation code Take advantage of Method object that work just like funcion pointers in languages such as C++ ","date":"2020-07-27","objectID":"/javareflection/:1:0","tags":["Java"],"title":"Java Reflection","uri":"/javareflection/"},{"categories":["Java"],"content":"The Class Class By working with the special Java class, you can access run time type identification information on all objects. The following code shows different way of get a Class Object Employee e; . . . Class c1 = e.getClass(); Class c2 = T.class; //T is any Java type; //e.g. java.util.Random Class c3 = Class.forName(className); //className //e.g. \"java.util.Random\" //Any method that calls this method needs a throws declearation. Comprehensive example Employee e = new Employee(); Class c1 = e.getClass(); String Name = c1.getName(); Class c2 = Employee.class(); Class c3 = Class.getClass(Name); // c1 == c2 == c3 Constructor constructor = c1.getConstructor(); Object obj = constructor.newInstance(Object...Params); ","date":"2020-07-27","objectID":"/javareflection/:2:0","tags":["Java"],"title":"Java Reflection","uri":"/javareflection/"},{"categories":["Java"],"content":"Using Reflection to Analyze the Capabilities of Classes Reflection mechanism allows you to examine the structure of a class Field Method Constructor Using the following program, we can analyze any class that the Java interpreter can load. package reflection; import java.util.*; import java.lang.reflect.*; public class ReflectionTest { public static void main(String[] args) throws ReflectiveOperationException{ String name; if (args.length \u003e 0) { name = args[0]; } else { var in = new Scanner(System.in); System.out.println(\"Enter class name (e.g. java.util.Date)\"); name = in.next(); } Class c1 = Class.forName(name); Class superc1 = c1.getSuperclass(); String modifiers = Modifier.toString(c1.getModifiers()); // 打印出类前的modifier if (modifiers.length() \u003e 0) { System.out.print(modifiers + \" \"); } // 打印类名 和 父类名 System.out.print(\"class \" + name + \" \"); if (superc1 != null \u0026\u0026 superc1 != Object.class) { System.out.print(\"extends \" + superc1.getName()); } System.out.print(\"\\n{\\n\"); printConstructors(c1); System.out.println(); printMethods(c1); System.out.println(); printFields(c1); System.out.println(\"}\"); } // 打印Constructor的 Modifier + name + parameterTpyes public static void printConstructors(Class c1) { Constructor[] constructors = c1.getDeclaredConstructors(); for (Constructor c : constructors) { String name = c.getName(); System.out.print(\" \"); String modifiers = Modifier.toString(c.getModifiers()); if (modifiers.length() \u003e 0) { System.out.print(modifiers + \" \"); } System.out.print(name + \"(\"); Class[] paramTypes = c.getParameterTypes(); for (int i = 0; i \u003c paramTypes.length; i++) { if (i \u003e 0) { System.out.print(\",\"); } System.out.print(paramTypes[i].getName()); } System.out.println(\");\"); } } // 打印Method的 modifier + returnTypes + name + parameterTypes private static void printMethods(Class c1) { Method[] methods = c1.getMethods(); for (Method m : methods) { Class retType = m.getReturnType(); String name = m.getName(); System.out.print(\" \"); String modifiers = Modifier.toString(m.getModifiers()); if (modifiers.length() \u003e 0) { System.out.print(modifiers + \" \"); } System.out.print(retType.getName() + \" \" + name + \"(\"); Class[] paramTypes = m.getParameterTypes(); for (int j = 0; j \u003c paramTypes.length; j++) { if (j \u003e 0) { System.out.print(\", \"); } System.out.print(paramTypes[j].getName()); } System.out.println(\");\"); } } // 打印Fields 的 Modifier parameterTypes Name private static void printFields(Class c1) { Field[] filelds = c1.getFields(); for (Field f : filelds) { Class type = f.getType(); String name = f.getName(); System.out.print(\" \"); String modifiers = Modifier.toString(f.getModifiers()); if (modifiers.length() \u003e 0) { System.out.print(modifiers + \" \"); } System.out.println(type.getName() + \" \" + name + \";\"); } } } ","date":"2020-07-27","objectID":"/javareflection/:3:0","tags":["Java"],"title":"Java Reflection","uri":"/javareflection/"},{"categories":["Java"],"content":"Using Reflection to Analyze Object at Runtime Of course, it is easy to look at the contents of a specific field of an object whose name and type are known when writing a program. But reflection lets you look at fields of objects that were not known at compile time. var harry = new Employee (\"Harry Hacker\", 50000, 10, 1, 1989); var jennie = new Employee(\"Jennie Kim\", 5000, 16, 1, 1996); Class c1 = harry.getClass(); Field f = c1.getDeclaredField(\"name\"); Object v= f.get(harry); f.set(harry, \"Harry Potter\"); //Only possible when \"name\" field is not private; f.setAccessible(true); //Now ok if call f.get(harry); Here is an example of a universal toString Method (是一个非常好的加深理解的例子) ObjectAnalyzerTest.java package objectAnalyzer; import java.util.*; /** * This program uses reflection to spy on object. */ public class ObjectAnalyzerTest { public static void main(String[] args) throws ReflectiveOperationException{ var squares = new ArrayList\u003cInteger\u003e(); System.out.println(Integer.class.isPrimitive()); for (int i = 1; i \u003c= 5; i++) { squares.add(i * i); } System.out.println(new ObjectAnalyzer().toString(squares)); } } ObjectAnalyzer.java package objectAnalyzer; import java.lang.reflect.AccessibleObject; import java.lang.reflect.Array; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.ArrayList; public class ObjectAnalyzer { private ArrayList\u003cObject\u003e visited = new ArrayList\u003c\u003e(); public String toString(Object obj) throws ReflectiveOperationException{ if (obj == null) return \"null\"; if (visited.contains(obj)) { return \"...\"; } visited.add(obj); Class c1 = obj.getClass(); if (c1 == String.class) { return (String) obj; } if (c1.isArray()) { String r = c1.getComponentType() + \"[]{\"; for (int i = 0; i \u003c Array.getLength(obj); i++) { if (i \u003e 0) { r += \",\"; } Object val = Array.get(obj, i); if (c1.getComponentType().isPrimitive()) r += val; else r += toString(val); } return r + \"}\"; } String r = c1.getName(); do { r += \"[\"; Field[] fields = c1.getDeclaredFields(); AccessibleObject.setAccessible(fields, true); for (Field f : fields) { if (!Modifier.isStatic(f.getModifiers())) { if (!r.endsWith(\"[\")) r+= \",\"; r += f.getName() + \"=\"; Class t = f.getType(); Object val = f.get(obj); if (t.isPrimitive()) r += val; else r+= toString(val); } } r += \"]\"; c1 = c1.getSuperclass(); } while (c1 != null); return r; } } ","date":"2020-07-27","objectID":"/javareflection/:4:0","tags":["Java"],"title":"Java Reflection","uri":"/javareflection/"},{"categories":["Java"],"content":"Using Reflection to Write Generic Array Code Allow you to create arrays dynamically. Problem: How can we write such a generic method? var a = new Employee[100]; a = Arrays.copyOf(a, 2 * a.length); One way is to create a new Object[] array in the method and return it. However, an array of objects cannot be cast to an array of employees. The virtual machine would generate a ClassCastException at runtime. The point is that, as we mentioned earlier, a Java array remembers the type of its entries – that is the element type used in the new expression that created it. It is legal to cast an Employee[] temporarily to an Object[] array and then cast it back. But an array that started its lef as an Object[] array can never be cast into an Employee[] array. Here is a good way to implement copy using reflection. public static Object goodCopyOf(Object a, int newLength) { Class c1 = a.getClass(); if (!c1.isArray()) return null; Class componentType = c1.getComponentType(); int length = Array.getLength(a); Object newArray = Array.newInstance(componentType, newLength); System.arraycopy(a,0,newArray,0,Math.min(length, newLength)); } ","date":"2020-07-27","objectID":"/javareflection/:5:0","tags":["Java"],"title":"Java Reflection","uri":"/javareflection/"},{"categories":["Java"],"content":"Invoking Arbitrary Methods and Constructors Recall that we can inspect a field of an object with getMethod of the Field class. Similarly, the Method class has an invoke method that lets you call the method that is wrapped in the current Method object. Object invoke(Object obj, Object... args) If the return type is a primitive type, the invoke method will return the wrapper type instead. Two ways to get the target Method object Class c = a.getClass(); Method[] methods = c.getDeclaredMethods(); // Then choose the specific method; // or Method method = c.getMethod(String name, Class... parameterTypes); ","date":"2020-07-27","objectID":"/javareflection/:6:0","tags":["Java"],"title":"Java Reflection","uri":"/javareflection/"},{"categories":["Blog"],"content":"个人搭建和修改博客的过程","date":"2020-07-16","objectID":"/nn%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","tags":["Blog"],"title":"NN的博客搭建","uri":"/nn%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Blog"],"content":"你好你好！ 1 博客框架采用了LoveIt 2 评论系统采用了Valine 3 添加了不同设备上的icon支持 4 修改了dark light mode的配色 …. ","date":"2020-07-16","objectID":"/nn%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:0:0","tags":["Blog"],"title":"NN的博客搭建","uri":"/nn%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"Markdown syntax \u0026 shortcuts 注意\r\r这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. \r\r 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧\r\r 将此页保存为书签，以备将来参考!\r\r ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:0:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID\r\r要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e \r\r ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:1:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:2:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:3:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:4:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:5:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:6:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:6:1","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:6:2","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:6:3","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗, 斜体和删除线***~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:6:4","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:7:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:8:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: * 一项内容 - 一项内容 + 一项内容 例如: * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:8:1","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧\r\r如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem \r\r ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:8:2","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:8:3","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:9:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:9:1","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments\rline 1 of code\rline 2 of code\rline 3 of code\r 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:9:2","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:9:3","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意\r\rHugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode.\r\r ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:9:4","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐\r\r在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. \r\r ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:10:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:11:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:11:1","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:11:2","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意\r\r定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了.\r\r ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:11:3","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:12:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \"\rThe Stormtroopocat\r 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The DojocatAlt text \"\rThe Dojocat\r 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧\r\rLoveIt 主题提供了一个包含更多功能的 图片的 shortcode.\r\r 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/markdown%E8%AF%AD%E6%B3%95/:13:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/markdown%E8%AF%AD%E6%B3%95/"}]